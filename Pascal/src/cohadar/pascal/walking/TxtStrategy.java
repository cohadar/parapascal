package cohadar.pascal.walking;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.antlr.runtime.Token;
import org.antlr.runtime.tree.CommonTree;
import org.antlr.runtime.tree.Tree;

import cohadar.pascal.PasErrs;
import cohadar.pascal.grammar.AbstractStrategy;
import cohadar.pascal.grammar.BParser;
import cohadar.pascal.grammar.CWalker;
import cohadar.pascal.grammar.TreeAttributes;
import cohadar.pascal.symtab.ConstantSymbol;
import cohadar.pascal.symtab.IType;
import cohadar.pascal.symtab.IVariable;
import cohadar.pascal.symtab.SymbolTable;
import cohadar.pascal.symtab.types.BuiltIn;
import cohadar.pascal.symtab.types.TypeFunction;
import cohadar.pascal.symtab.types.TypeRange;
import cohadar.util.Util;

public class TxtStrategy extends AbstractStrategy {
	private final SymbolTable symtab;
	private final TreeAttributes attribs;

	public TxtStrategy(SymbolTable symtab, TreeAttributes attribs) {
		this.symtab = symtab;
		this.attribs = attribs;
	}

	StringBuilder ret = new StringBuilder();

	String mainBody = "";

	private int labelIndex = 0;
	private int forkIndex = 1;

	private final List<String> instances = new ArrayList<String>();
	private final List<String> shareds = new ArrayList<String>();
	private final List<String> subprograms = new ArrayList<String>();
	private final Map<IVariable, Integer> regions = new HashMap<IVariable, Integer>();

	// ========================================================================
	public void reset() {
		ret.setLength(0);
		mainBody = null;
		labelIndex = 0;
		forkIndex = 1;
		instances.clear();
		shareds.clear();
		subprograms.clear();
		regions.clear();
	}

	@Override
	public String toString() {
		return ret.toString();
	}

	@Override
	public void program(CommonTree program) {
		if (shareds.size() > 0) {
			ret.append(".SHARED\n");
			for (String s : shareds) {
				ret.append(s);
			}
		}
		if (regions.size() > 0) {
			ret.append(".SHARED\n");
			for (int i = 0; i < regions.size(); i++) {
				ret.append(String.format("\t%s : 1\n", Format.regionName(i)));
			}
		}
		if (instances.size() > 0) {
			ret.append(".INSTANCE\n");
			for (String s : instances) {
				ret.append(s);
			}
		}

		ret.append(".CODE\n");

		for (String s : subprograms) {
			ret.append("\n//======================================\n");
			ret.append(s);
			ret.append("\tret");
		}

		ret.append("\n//======================================\n");
		ret.append("@main():\n");
		if (regions.size() > 0) {
			ret.append(Format.comment("INITIALIZE REGION SEMAPHORES"));
			for (int i = 0; i < regions.size(); i++) {
				ret.append(Format.addr(Format.regionName(i)));
				ret.append(Format._const(1));
				ret.append(Format.syscall("SEM_INIT"));
			}
			ret.append("\n");
		}
		ret.append(mainBody);
		ret.append("\texit 0\n");
	}

	@Override
	public void variableDeclaration(boolean shared, boolean global, CommonTree idList, CommonTree typeRoot) {
		if (global) {
			IType type = attribs.getType(typeRoot);
			for (int i = 0; i < idList.getChildCount(); i++) {
				CommonTree id = (CommonTree) idList.getChild(i);
				if (typeRoot.getType() == BParser.SEMAPHORE) {
					shared = true;
				}
				if (shared) {
					shareds.add(String.format("\t%s : %d\t// %s\n", id.getText(), type.getSize(), type));
				} else {
					instances.add(String.format("\t%s : %d\t// %s\n", id.getText(), type.getSize(), type));
				}
			}
		} else {
			// local variables are generated by functionDeclaration
		}
	}

	@Override
	public void variable(boolean lhs, CommonTree id) {
		// is it a constant?
		IVariable sym = attribs.getVariable(id);
		if (sym instanceof ConstantSymbol) {
			ConstantSymbol c = ((ConstantSymbol) sym);
			attribs.linkString(id, Format._const(c.getConstant().getValue()));
			return;
		}

		IType type = attribs.getType(id);
		boolean noSuffix = (id.getChildCount() == 0);
		boolean byValue = !attribs.getVariable(id).isReference();

		String s = "";

		if (lhs && type instanceof TypeRange) {
			TypeRange range = (TypeRange) type;
			s += Format.comment("check range");
			s += Format._const(range.getLow());
			s += Format._const(range.getHigh());
			s += Format.range();
		}

		for (int i = 0; i < id.getChildCount(); i++) {
			s += variableSuffix(id, i);
		}

		if (id.hasAncestor(BParser.CALL)) {
			String addr = Format.variableAddr(id.getText(), byValue, noSuffix);
			attribs.linkADDR(id, s + addr);
		}

		if (lhs) {
			s += Format.variableStore(id.getText(), byValue, noSuffix, type.getSize());
		} else {
			s += Format.variableLoad(id.getText(), byValue, noSuffix, type.getSize());
		}
		attribs.linkString(id, s);
	}

	private String variableSuffix(CommonTree id, int childIndex) {
		String ret = "";
		CommonTree suffix = (CommonTree) id.getChild(childIndex);
		switch (suffix.getType()) {
		case BParser.LBRACK: {
			ret = arrayField(id, childIndex, suffix);
			break;
		}
		case BParser.DOT: {
			ret = recordField(id, childIndex, suffix);
			break;
		}
		default: {
			throw new RuntimeException("Invalid variable suffix type");
		}
		}
		return ret;
	}

	public String arrayField(CommonTree id, int childIndex, CommonTree lbrack) {
		IType base = attribs.getType(lbrack);
		TypeRange range = (TypeRange) attribs.getType2(lbrack);
		String index = Format.comment("array index" + childIndex) + attribs.getString(lbrack.getChild(0));

		// check if index in array bounds and shift to zero
		index += Format.comment("check range");
		index += Format._const(range.getLow());
		index += Format._const(range.getHigh());
		index += Format.index();

		// multiply index by field size
		int size = base.getSize();
		if (size > 1) {
			index += Format.comment("multiply by field size");
			index += Format._const(size);
			index += Format.mul();
		}

		// add to previous index?
		if (childIndex > 0) {
			index += Format.comment("add to previous index");
			index += Format.add();
		}

		return index;
	}

	public String recordField(CommonTree id, int childIndex, CommonTree dot) {
		String index = Format.comment("field index" + childIndex);
		int offset = attribs.getInteger(dot);
		index += Format._const(offset);

		// add to previous index?
		if (childIndex > 0) {
			index += Format.comment("add to previous index");
			index += Format.add();
		}

		return index;
	}

	@Override
	public void literal(CommonTree node) {
		if (node.getType() == BParser.HEX_INT) {
			String s = Format._const("0x" + node.getText().substring(1));
			attribs.linkString(node, s);
		} else {
			String s = Format._const(node.getText());
			attribs.linkString(node, s);
		}
	}

	@Override
	public void logicOperator(CommonTree op, CommonTree a, CommonTree b) {
		String x = attribs.getString(a);
		String y = attribs.getString(b);
		String z = String.format("%s%s\t%s\n", x, y, getOperation(op.getToken()));
		attribs.linkString(op, z);
	}

	@Override
	public void comparisonOperator(CommonTree op, CommonTree a, CommonTree b) {
		String x = attribs.getString(a);
		String y = attribs.getString(b);
		if (attribs.getPromote(a) != null) {
			x += Format.i2f();
		}
		if (attribs.getPromote(b) != null) {
			y += Format.i2f();
		}
		String z = String.format("%s%s\t%s\n", x, y, getOperation(op));
		attribs.linkString(op, z);
	}

	@Override
	public void equalityOperator(CommonTree op, CommonTree a, CommonTree b) {
		String x = attribs.getString(a);
		String y = attribs.getString(b);
		if (attribs.getPromote(a) != null) {
			x += Format.i2f();
		}
		if (attribs.getPromote(b) != null) {
			y += Format.i2f();
		}
		String z = String.format("%s%s\t%s\n", x, y, getOperation(op));
		attribs.linkString(op, z);
	}

	@Override
	public void arithmeticOperator(CommonTree op, CommonTree a, CommonTree b) {
		String x = attribs.getString(a);
		String y = attribs.getString(b);
		if (attribs.getPromote(a) != null) {
			x += Format.i2f();
		}
		if (attribs.getPromote(b) != null) {
			y += Format.i2f();
		}
		String z = String.format("%s%s\t%s\n", x, y, getOperation(op));
		attribs.linkString(op, z);
	}

	@Override
	public void unaryMinus(CommonTree op, CommonTree b) {
		String y = attribs.getString(b);
		String z = String.format("%s\t%s\n", y, getOperation(op.getToken()));
		attribs.linkString(op, z);
	}

	@Override
	public void not(CommonTree op, CommonTree b) {
		String y = attribs.getString(b);
		String z = String.format("%s\t%s\n", y, getOperation(op.getToken()));
		attribs.linkString(op, z);
	}

	@Override
	public void functionDeclaration(CommonTree id, CommonTree paramListNode, CommonTree localListNode, CommonTree body,
			CommonTree retType) {
		TypeFunction func = symtab.resolveFunction(id.getText());

		String retSize = "";
		if (retType != null) {
			retSize = Integer.toString(attribs.getType(retType).getSize());
		}

		String paramNames = "";
		List<Tree> paramList = attribs.getList(paramListNode);
		if (paramList != null) {
			List<String> p = new ArrayList<String>();
			int index = 0;
			for (Tree t : paramList) {
				IVariable s = attribs.getVariable(t);
				int size = s.getType().getSize();
				if (size == 1 || func.isArgumentReference(index)) {
					p.add(s.getName());
				} else {
					p.add(String.format("%s:%d", s.getName(), size));
				}
				index++;
			}
			paramNames = Util.replicate(", ", p);
		}

		String localNames = "";
		List<Tree> localsList = attribs.getList(localListNode);
		if (localsList != null) {
			List<String> p = new ArrayList<String>();
			for (Tree t : localsList) {
				IVariable s = attribs.getVariable(t);
				int size = s.getType().getSize();
				if (size == 1) {
					p.add(s.getName());
				} else {
					p.add(String.format("%s:%d", s.getName(), size));
				}
			}
			localNames = Util.replicate(", ", p);
		}

		String ret = null;
		if (localNames.length() > 0) {
			ret = String.format("@%s(%s){%s}:%s\n", id.getText(), paramNames, localNames, retSize);
		} else {
			ret = String.format("@%s(%s):%s\n", id.getText(), paramNames, retSize);
		}
		ret += attribs.getString(body);
		subprograms.add(ret);
	}

	// transfer all arguments to debug stack
	public void debug(CommonTree call) {
		String args = "";
		for (int i = 0; i < call.getChildCount(); i++) {
			Tree e = call.getChild(i);
			args += attribs.getString(e);
			args += Format.syscall("DEBUG");
		}
		attribs.linkString(call, args);
	}

	public void writeCall(CommonTree call, boolean nl) {
		String args = "";
		for (int i = 0; i < call.getChildCount(); i++) {
			Tree e = call.getChild(i);
			args += attribs.getString(e);
			IType t = attribs.getType(e);
			switch (t.getCategory()) {
			case INTEGER: {
				args += Format.syscall("PRINT_INTEGER");
				break;
			}
			case REAL: {
				args += Format.syscall("PRINT_REAL");
				break;
			}
			case BOOLEAN: {
				args += Format.syscall("PRINT_BOOLEAN");
				break;
			}
			case STRING: {
				args += Format.syscall("PRINT_CREF");
				break;
			}
			default: {
				symtab.erlog.append(PasErrs.BAD_WRITE_ARGUMENT, call.getLine(), "Cannot write type: " + t.getName());
			}
			}
		}
		if (nl) {
			args += Format.syscall("PRINT_NL");
		}
		attribs.linkString(call, args);
	}

	private void functionCall(CommonTree call, boolean system) {
		TypeFunction sig = symtab.resolveFunction(call.getText());

		String args = "";
		for (int i = 0; i < sig.getArgumentCount(); i++) {
			if (sig.isArgumentReference(i)) {
				String addr = attribs.getADDR(call.getChild(i));
				if (addr == null) {
					symtab.erlog.append(PasErrs.EXPECTED_REFERENCE, call.getLine(), "argument #%d must be a reference",
							i);
					return;
				}
				args += addr;
			} else {
				args += attribs.getString(call.getChild(i));
			}
			if (attribs.getPromote(call.getChild(i)) != null) {
				args += Format.i2f();
			}
		}
		if (system) {
			args += Format.syscall(sig.getAsmName());
		} else {
			args += Format.call(sig.getAsmName());
		}
		attribs.linkString(call, args);
	}

	@Override
	public void functionCall(CommonTree call) {
		if ("write".equals(call.getText())) {
			writeCall(call, false);
		} else if ("writeln".equals(call.getText())) {
			writeCall(call, true);
		} else if ("debug".equals(call.getText())) {
			debug(call);
		} else if (BuiltIn.isPredefinedFunction(call.getText())) {
			functionCall(call, true);
		} else {
			functionCall(call, false);
		}
	}

	private String getOperation(CommonTree operation) {
		if (attribs.getType(operation) == BuiltIn.REAL) {
			return "f" + getOperation(operation.getToken());
		} else {
			return getOperation(operation.getToken());
		}
	}

	private String getOperation(Token operation) {
		switch (operation.getType()) {
		case CWalker.PLUS:
			return "add";
		case CWalker.MINUS:
			return "sub";
		case CWalker.UNARY_MINUS:
			return "neg";
		case CWalker.STAR:
			return "mul";
		case CWalker.SLASH:
		case CWalker.DIV:
			return "div";
		case CWalker.MOD:
			return "mod";
		case CWalker.GT:
			return "gt";
		case CWalker.GE:
			return "gte";
		case CWalker.LT:
			return "lt";
		case CWalker.LE:
			return "lte";
		case CWalker.EQUAL:
			return "eq";
		case CWalker.NOT_EQUAL:
			return "neq";
		case CWalker.AND:
			return "and";
		case CWalker.OR:
			return "or";
		case CWalker.XOR:
			return "xor";
		case CWalker.NOT:
			return "not";
		default:
			return String.format("<UNKNOWN='%s'>", operation.getText());
		}
	}

	@Override
	public void assignmentStatement(CommonTree assign, CommonTree variable, CommonTree expression) {
		String ret = Format.comment(":=");
		ret += attribs.getString(expression);
		ret += attribs.getString(variable);
		attribs.linkString(assign, ret);
	}

	@Override
	public void mainBody(CommonTree begin) {
		mainBody = attribs.getString(begin);
	}

	@Override
	public void compoundStatement(CommonTree begin) {
		String s = "";
		for (int i = 0; i < begin.getChildCount(); i++) {
			CommonTree t = (CommonTree) begin.getChild(i);
			s += attribs.getString(t);
		}
		attribs.linkString(begin, s);
	}

	private String coStatement(String statement) {
		String ret = Format.comment("FORK");
		ret += Format.startFork(forkIndex);
		ret += statement;
		ret += Format.endFork(forkIndex);
		forkIndex++;
		return ret;
	}

	@Override
	public void cobeginStatement(CommonTree cobegin) {
		String ret = "";
		for (int i = 0; i < cobegin.getChildCount(); i++) {
			CommonTree child = (CommonTree) cobegin.getChild(i);
			String statement = attribs.getString(child);
			if (child.getType() == BParser.COFOR) {
				ret += statement;
			} else {
				ret += coStatement(statement);
			}
		}
		ret += Format.comment("JOIN");
		ret += Format.join();
		attribs.linkString(cobegin, ret);
	}

	@Override
	public void ifStatement(CommonTree _if, CommonTree _condition, CommonTree _then, CommonTree _else) {
		String ret = Format.comment("IF");
		if (_else == null) {
			ret += attribs.getString(_condition);
			ret += Format.brf(labelIndex);
			ret += Format.comment("THEN");
			ret += attribs.getString(_then);
			ret += Format.label(labelIndex);
			labelIndex += 1;
		} else {
			ret += attribs.getString(_condition);
			ret += Format.brf(labelIndex);
			ret += Format.comment("THEN");
			ret += attribs.getString(_then);
			ret += Format.br(labelIndex + 1);
			ret += Format.label(labelIndex);
			ret += Format.comment("ELSE");
			ret += attribs.getString(_else);
			ret += Format.label(labelIndex + 1);
			labelIndex += 2;
		}
		attribs.linkString(_if, ret);
	}

	@Override
	public void whileStatement(CommonTree _while, CommonTree _condition, CommonTree _do) {
		String ret = Format.comment("WHILE");
		if (_do == null) {
			ret += Format.comment("condition");
			ret += Format.label(labelIndex);
			ret += attribs.getString(_condition);
			ret += Format.brt(labelIndex);
			labelIndex += 1;
		} else {
			ret += Format.br(labelIndex + 1);
			ret += Format.label(labelIndex);
			ret += Format.comment("DO");
			ret += attribs.getString(_do);
			ret += Format.label(labelIndex + 1);
			ret += Format.comment("condition (while)");
			ret += attribs.getString(_condition);
			ret += Format.brt(labelIndex);
			labelIndex += 2;
		}

		// break label
		Integer breakIndex = attribs.getInteger(_while);
		if (breakIndex != null) {
			ret += Format.label(breakIndex);
		}

		attribs.linkString(_while, ret);
	}

	@Override
	public void repeatStatement(CommonTree _repeat, CommonTree _doList, CommonTree _condition) {
		String ret = Format.label(labelIndex);
		ret += Format.comment("REPEAT");
		for (int i = 0; i < _doList.getChildCount(); i++) {
			Tree _do = _doList.getChild(i);
			ret += attribs.getString(_do);
		}
		ret += Format.comment("UNTIL");
		ret += attribs.getString(_condition);
		ret += Format.brf(labelIndex);
		labelIndex += 1;

		// break label
		Integer breakIndex = attribs.getInteger(_repeat);
		if (breakIndex != null) {
			ret += Format.label(breakIndex);
		}

		attribs.linkString(_repeat, ret);
	}

	private void forStatement(boolean co, CommonTree _for, boolean downto, CommonTree _start, CommonTree _end,
			CommonTree _do) {
		String index = _for.getText();

		String ret = "";

		if (co) {
			ret += Format.comment("COFOR");
		} else {
			ret += Format.comment("FOR");
		}

		ret += Format.comment("index := start");
		ret += attribs.getString(_start);
		ret += Format.addr(index);
		ret += Format.store();
		ret += Format.br(labelIndex + 1);

		// do statement
		ret += Format.label(labelIndex);
		if (_do != null) {
			ret += Format.comment("DO");
			if (co) {
				ret += coStatement(attribs.getString(_do));
			} else {
				ret += attribs.getString(_do);
			}
		}

		if (downto) {
			ret += Format.comment("index--");
			ret += Format.addr(index);
			ret += Format.load();
			ret += Format.dec();
			ret += Format.addr(index);
			ret += Format.store();

			ret += Format.label(labelIndex + 1);
			ret += Format.comment("condition (index >= end)");
			ret += Format.addr(index);
			ret += Format.load();
			ret += attribs.getString(_end);
			ret += Format.gte();
		} else {
			ret += Format.comment("index++");
			ret += Format.addr(index);
			ret += Format.load();
			ret += Format.inc();
			ret += Format.addr(index);
			ret += Format.store();

			ret += Format.label(labelIndex + 1);
			ret += Format.comment("condition (index <= end)");
			ret += Format.addr(index);
			ret += Format.load();
			ret += attribs.getString(_end);
			ret += Format.lte();
		}
		ret += Format.brt(labelIndex);

		// break label
		Integer breakIndex = attribs.getInteger(_for);
		if (breakIndex != null) {
			ret += Format.label(breakIndex);
		}

		// ===============
		labelIndex += 2;
		attribs.linkString(_for, ret);
	}

	@Override
	public void forStatement(CommonTree _for, boolean downto, CommonTree _start, CommonTree _end, CommonTree _do) {
		forStatement(false, _for, downto, _start, _end, _do);
	}

	@Override
	public void coforStatement(CommonTree _cofor, boolean downto, CommonTree _start, CommonTree _end, CommonTree _do) {
		forStatement(true, _cofor, downto, _start, _end, _do);
	}

	private int getRegionVariableId(CommonTree variable) {
		IVariable sym = attribs.getVariable(variable);
		Integer id = regions.get(sym);
		if (id == null) {
			id = regions.size();
			regions.put(sym, id);
		}
		return id;
	}

	@Override
	public void regionStatement(CommonTree region, CommonTree variable, CommonTree statement) {
		int id = getRegionVariableId(variable);

		String ret = Format.comment("REGION");
		ret += Format.addr(Format.regionName(id));
		ret += Format.load();
		ret += Format.syscall("SEM_WAIT");

		ret += attribs.getString(statement);

		ret += Format.addr(Format.regionName(id));
		ret += Format.load();
		ret += Format.syscall("SEM_SIGNAL");
		attribs.linkString(region, ret);
	}

	@Override
	public void awaitStatement(CommonTree await, CommonTree _condition) {
		CommonTree region = (CommonTree) await.getAncestor(BParser.REGION);
		int id = getRegionVariableId((CommonTree) region.getChild(0));

		String ret = Format.comment("AWAIT");
		ret += Format.br(labelIndex + 1);
		ret += Format.label(labelIndex);

		ret += Format.addr(Format.regionName(id));
		ret += Format.load();
		ret += Format.syscall("SEM_SIGNAL");
		ret += Format.addr(Format.regionName(id));
		ret += Format.load();
		ret += Format.syscall("SEM_WAIT");

		ret += Format.label(labelIndex + 1);
		ret += Format.comment("condition (await)");
		ret += attribs.getString(_condition);
		ret += Format.brf(labelIndex);
		labelIndex += 2;

		attribs.linkString(await, ret);
	}

	@Override
	public void breakStatement(CommonTree _break) {
		CommonTree parent = Common.getBreakParent(_break);
		Integer index = attribs.getInteger(parent);
		if (index == null) {
			index = labelIndex++;
			attribs.linkInteger(parent, index);
		}
		attribs.linkString(_break, Format.comment("break") + Format.br(index));
	}
}
